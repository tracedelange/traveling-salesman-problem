{"ast":null,"code":"/*!\n * @pixi/spritesheet - v6.0.4\n * Compiled Tue, 11 May 2021 18:00:23 UTC\n *\n * @pixi/spritesheet is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Rectangle } from '@pixi/math';\nimport { Texture, BaseTexture } from '@pixi/core';\nimport { getResolutionOfUrl, url } from '@pixi/utils';\nimport { LoaderResource } from '@pixi/loaders';\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.Loader.shared.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\n\nvar Spritesheet =\n/** @class */\nfunction () {\n  /**\n   * @param {PIXI.BaseTexture|PIXI.Texture} baseTexture - Reference to the source BaseTexture object.\n   * @param {Object} data - Spritesheet image data.\n   * @param {string} [resolutionFilename] - The filename to consider when determining\n   *        the resolution of the spritesheet. If not provided, the imageUrl will\n   *        be used on the BaseTexture.\n   */\n  function Spritesheet(texture, data, resolutionFilename) {\n    if (resolutionFilename === void 0) {\n      resolutionFilename = null;\n    }\n    /**\n     * Reference to original source image from the Loader. This reference is retained so we\n     * can destroy the Texture later on. It is never used internally.\n     * @type {PIXI.Texture}\n     * @private\n     */\n\n\n    this._texture = texture instanceof Texture ? texture : null;\n    /**\n     * Reference to ths source texture.\n     * @type {PIXI.BaseTexture}\n     */\n\n    this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link PIXI.Sprite|Sprite}:\n     * ```js\n     * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n     * ```\n     * @member {Object}\n     */\n\n    this.textures = {};\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:\n     * ```js\n     * new PIXI.AnimatedSprite(sheet.animations[\"anim_name\"])\n     * ```\n     * @member {Object}\n     */\n\n    this.animations = {};\n    /**\n     * Reference to the original JSON data.\n     * @type {Object}\n     */\n\n    this.data = data;\n    var resource = this.baseTexture.resource;\n    /**\n     * The resolution of the spritesheet.\n     * @type {number}\n     */\n\n    this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n    /**\n     * Map of spritesheet frames.\n     * @type {Object}\n     * @private\n     */\n\n    this._frames = this.data.frames;\n    /**\n     * Collection of frame names.\n     * @type {string[]}\n     * @private\n     */\n\n    this._frameKeys = Object.keys(this._frames);\n    /**\n     * Current batch index being processed.\n     * @type {number}\n     * @private\n     */\n\n    this._batchIndex = 0;\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     * @private\n     */\n\n    this._callback = null;\n  }\n  /**\n   * Generate the resolution from the filename or fallback\n   * to the meta.scale field of the JSON data.\n   *\n   * @private\n   * @param {string} resolutionFilename - The filename to use for resolving\n   *        the default resolution.\n   * @return {number} Resolution to use for spritesheet.\n   */\n\n\n  Spritesheet.prototype._updateResolution = function (resolutionFilename) {\n    if (resolutionFilename === void 0) {\n      resolutionFilename = null;\n    }\n\n    var scale = this.data.meta.scale; // Use a defaultValue of `null` to check if a url-based resolution is set\n\n    var resolution = getResolutionOfUrl(resolutionFilename, null); // No resolution found via URL\n\n    if (resolution === null) {\n      // Use the scale value or default to 1\n      resolution = scale !== undefined ? parseFloat(scale) : 1;\n    } // For non-1 resolutions, update baseTexture\n\n\n    if (resolution !== 1) {\n      this.baseTexture.setResolution(resolution);\n    }\n\n    return resolution;\n  };\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   *\n   * @param {Function} callback - Callback when complete returns\n   *        a map of the Textures for this spritesheet.\n   */\n\n\n  Spritesheet.prototype.parse = function (callback) {\n    this._batchIndex = 0;\n    this._callback = callback;\n\n    if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {\n      this._processFrames(0);\n\n      this._processAnimations();\n\n      this._parseComplete();\n    } else {\n      this._nextBatch();\n    }\n  };\n  /**\n   * Process a batch of frames\n   *\n   * @private\n   * @param {number} initialFrameIndex - The index of frame to start.\n   */\n\n\n  Spritesheet.prototype._processFrames = function (initialFrameIndex) {\n    var frameIndex = initialFrameIndex;\n    var maxFrames = Spritesheet.BATCH_SIZE;\n\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      var i = this._frameKeys[frameIndex];\n      var data = this._frames[i];\n      var rect = data.frame;\n\n      if (rect) {\n        var frame = null;\n        var trim = null;\n        var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n\n        if (data.rotated) {\n          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n        } else {\n          frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        } //  Check to see if the sprite is trimmed\n\n\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n        }\n\n        this.textures[i] = new Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor); // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n\n        Texture.addToCache(this.textures[i], i);\n      }\n\n      frameIndex++;\n    }\n  };\n  /**\n   * Parse animations config\n   *\n   * @private\n   */\n\n\n  Spritesheet.prototype._processAnimations = function () {\n    var animations = this.data.animations || {};\n\n    for (var animName in animations) {\n      this.animations[animName] = [];\n\n      for (var i = 0; i < animations[animName].length; i++) {\n        var frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  };\n  /**\n   * The parse has completed.\n   *\n   * @private\n   */\n\n\n  Spritesheet.prototype._parseComplete = function () {\n    var callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  };\n  /**\n   * Begin the next batch of textures.\n   *\n   * @private\n   */\n\n\n  Spritesheet.prototype._nextBatch = function () {\n    var _this = this;\n\n    this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n\n    this._batchIndex++;\n    setTimeout(function () {\n      if (_this._batchIndex * Spritesheet.BATCH_SIZE < _this._frameKeys.length) {\n        _this._nextBatch();\n      } else {\n        _this._processAnimations();\n\n        _this._parseComplete();\n      }\n    }, 0);\n  };\n  /**\n   * Destroy Spritesheet and don't use after this.\n   *\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n\n\n  Spritesheet.prototype.destroy = function (destroyBase) {\n    var _a;\n\n    if (destroyBase === void 0) {\n      destroyBase = false;\n    }\n\n    for (var i in this.textures) {\n      this.textures[i].destroy();\n    }\n\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n\n    if (destroyBase) {\n      (_a = this._texture) === null || _a === void 0 ? void 0 : _a.destroy();\n      this.baseTexture.destroy();\n    }\n\n    this._texture = null;\n    this.baseTexture = null;\n  };\n  /**\n   * The maximum number of Textures to build per process.\n   *\n   * @type {number}\n   * @default 1000\n   */\n\n\n  Spritesheet.BATCH_SIZE = 1000;\n  return Spritesheet;\n}();\n/**\n * Reference to Spritesheet object created.\n * @member {PIXI.Spritesheet} spritesheet\n * @memberof PIXI.ILoaderResource\n * @instance\n */\n\n/**\n * Dictionary of textures from Spritesheet.\n * @member {object<string, PIXI.Texture>} textures\n * @memberof PIXI.ILoaderResource\n * @instance\n */\n\n/**\n * {@link PIXI.Loader} middleware for loading texture atlases that have been created with\n * TexturePacker or similar JSON-based spritesheet.\n *\n * This middleware automatically generates Texture resources.\n *\n * If you're using Webpack or other bundlers and plan on bundling the atlas' JSON,\n * use the {@link PIXI.Spritesheet} class to directly parse the JSON.\n *\n * The Loader's image Resource name is automatically appended with `\"_image\"`.\n * If a Resource with this name is already loaded, the Loader will skip parsing the\n * Spritesheet. The code below will generate an internal Loader Resource called `\"myatlas_image\"`.\n *\n * @example\n * loader.add('myatlas', 'path/to/myatlas.json');\n * loader.load(() => {\n *   loader.resources.myatlas; // atlas JSON resource\n *   loader.resources.myatlas_image; // atlas Image resource\n * });\n *\n * @class\n * @memberof PIXI\n * @implements PIXI.ILoaderPlugin\n */\n\n\nvar SpritesheetLoader =\n/** @class */\nfunction () {\n  function SpritesheetLoader() {}\n  /**\n   * Called after a resource is loaded.\n   * @see PIXI.Loader.loaderMiddleware\n   * @param {PIXI.LoaderResource} resource\n   * @param {function} next\n   */\n\n\n  SpritesheetLoader.use = function (resource, next) {\n    var _a, _b; // because this is middleware, it execute in loader context. `this` = loader\n\n\n    var loader = this;\n    var imageResourceName = resource.name + \"_image\"; // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n\n    if (!resource.data || resource.type !== LoaderResource.TYPE.JSON || !resource.data.frames || loader.resources[imageResourceName]) {\n      next();\n      return;\n    } // Check and add the multi atlas\n    // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n    // eslint-disable-next-line camelcase\n\n\n    var multiPacks = (_b = (_a = resource.data) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.related_multi_packs;\n\n    if (Array.isArray(multiPacks)) {\n      var _loop_1 = function (item) {\n        if (typeof item !== 'string') {\n          return \"continue\";\n        }\n\n        var itemName = item.replace('.json', '');\n        var itemUrl = url.resolve(resource.url.replace(loader.baseUrl, ''), item); // Check if the file wasn't already added as multipacks are redundant\n\n        if (loader.resources[itemName] || Object.values(loader.resources).some(function (r) {\n          return url.format(url.parse(r.url)) === itemUrl;\n        })) {\n          return \"continue\";\n        }\n\n        var options = {\n          crossOrigin: resource.crossOrigin,\n          loadType: LoaderResource.LOAD_TYPE.XHR,\n          xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n          parentResource: resource\n        };\n        loader.add(itemName, itemUrl, options);\n      };\n\n      for (var _i = 0, multiPacks_1 = multiPacks; _i < multiPacks_1.length; _i++) {\n        var item = multiPacks_1[_i];\n\n        _loop_1(item);\n      }\n    }\n\n    var loadOptions = {\n      crossOrigin: resource.crossOrigin,\n      metadata: resource.metadata.imageMetadata,\n      parentResource: resource\n    };\n    var resourcePath = SpritesheetLoader.getResourcePath(resource, loader.baseUrl); // load the image for this sheet\n\n    loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {\n      if (res.error) {\n        next(res.error);\n        return;\n      }\n\n      var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);\n      spritesheet.parse(function () {\n        resource.spritesheet = spritesheet;\n        resource.textures = spritesheet.textures;\n        next();\n      });\n    });\n  };\n  /**\n   * Get the spritesheets root path\n   * @param {PIXI.LoaderResource} resource - Resource to check path\n   * @param {string} baseUrl - Base root url\n   */\n\n\n  SpritesheetLoader.getResourcePath = function (resource, baseUrl) {\n    // Prepend url path unless the resource image is a data url\n    if (resource.isDataUrl) {\n      return resource.data.meta.image;\n    }\n\n    return url.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);\n  };\n\n  return SpritesheetLoader;\n}();\n\nexport { Spritesheet, SpritesheetLoader };","map":{"version":3,"sources":["../../src/Spritesheet.ts","../../src/SpritesheetLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import { Rectangle } from '@pixi/math';\nimport { Texture, BaseTexture } from '@pixi/core';\nimport { getResolutionOfUrl } from '@pixi/utils';\nimport type { Dict } from '@pixi/utils';\nimport type { ImageResource } from '@pixi/core';\nimport type { IPointData } from '@pixi/math';\n\n/**\n * Represents the JSON data for a spritesheet atlas.\n */\nexport interface ISpritesheetFrameData {\n    frame: {\n        x: number;\n        y: number;\n        w: number;\n        h: number;\n    };\n    trimmed?: boolean;\n    rotated?: boolean;\n    sourceSize?: {\n        w: number;\n        h: number;\n    };\n    spriteSourceSize?: {\n        x: number;\n        y: number;\n    };\n    anchor?: IPointData;\n}\n\n/**\n * Atlas format.\n */\nexport interface ISpritesheetData {\n    frames: Dict<ISpritesheetFrameData>;\n    animations?: Dict<string[]>;\n    meta: {\n        scale: string;\n    };\n}\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.Loader.shared.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\nexport class Spritesheet\n{\n    /**\n     * The maximum number of Textures to build per process.\n     *\n     * @type {number}\n     * @default 1000\n     */\n    static readonly BATCH_SIZE = 1000;\n\n    public baseTexture: BaseTexture;\n    public textures: Dict<Texture>;\n    public animations: Dict<Texture[]>;\n    public data: ISpritesheetData;\n    public resolution: number;\n\n    private _texture: Texture;\n    private _frames: Dict<ISpritesheetFrameData>;\n    private _frameKeys: string[];\n    private _batchIndex: number;\n    private _callback: (textures: Dict<Texture>) => void;\n\n    /**\n     * @param {PIXI.BaseTexture|PIXI.Texture} baseTexture - Reference to the source BaseTexture object.\n     * @param {Object} data - Spritesheet image data.\n     * @param {string} [resolutionFilename] - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n    constructor(texture: BaseTexture | Texture, data: ISpritesheetData, resolutionFilename: string = null)\n    {\n        /**\n         * Reference to original source image from the Loader. This reference is retained so we\n         * can destroy the Texture later on. It is never used internally.\n         * @type {PIXI.Texture}\n         * @private\n         */\n        this._texture = texture instanceof Texture ? texture : null;\n\n        /**\n         * Reference to ths source texture.\n         * @type {PIXI.BaseTexture}\n         */\n        this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;\n\n        /**\n         * A map containing all textures of the sprite sheet.\n         * Can be used to create a {@link PIXI.Sprite|Sprite}:\n         * ```js\n         * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n         * ```\n         * @member {Object}\n         */\n        this.textures = {};\n\n        /**\n         * A map containing the textures for each animation.\n         * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:\n         * ```js\n         * new PIXI.AnimatedSprite(sheet.animations[\"anim_name\"])\n         * ```\n         * @member {Object}\n         */\n        this.animations = {};\n\n        /**\n         * Reference to the original JSON data.\n         * @type {Object}\n         */\n        this.data = data;\n\n        const resource = this.baseTexture.resource as ImageResource;\n\n        /**\n         * The resolution of the spritesheet.\n         * @type {number}\n         */\n        this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n\n        /**\n         * Map of spritesheet frames.\n         * @type {Object}\n         * @private\n         */\n        this._frames = this.data.frames;\n\n        /**\n         * Collection of frame names.\n         * @type {string[]}\n         * @private\n         */\n        this._frameKeys = Object.keys(this._frames);\n\n        /**\n         * Current batch index being processed.\n         * @type {number}\n         * @private\n         */\n        this._batchIndex = 0;\n\n        /**\n         * Callback when parse is completed.\n         * @type {Function}\n         * @private\n         */\n        this._callback = null;\n    }\n\n    /**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     *\n     * @private\n     * @param {string} resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @return {number} Resolution to use for spritesheet.\n     */\n    private _updateResolution(resolutionFilename: string = null): number\n    {\n        const { scale } = this.data.meta;\n\n        // Use a defaultValue of `null` to check if a url-based resolution is set\n        let resolution = getResolutionOfUrl(resolutionFilename, null);\n\n        // No resolution found via URL\n        if (resolution === null)\n        {\n            // Use the scale value or default to 1\n            resolution = scale !== undefined ? parseFloat(scale) : 1;\n        }\n\n        // For non-1 resolutions, update baseTexture\n        if (resolution !== 1)\n        {\n            this.baseTexture.setResolution(resolution);\n        }\n\n        return resolution;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     *\n     * @param {Function} callback - Callback when complete returns\n     *        a map of the Textures for this spritesheet.\n     */\n    public parse(callback: () => void): void\n    {\n        this._batchIndex = 0;\n        this._callback = callback;\n\n        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n        {\n            this._processFrames(0);\n            this._processAnimations();\n            this._parseComplete();\n        }\n        else\n        {\n            this._nextBatch();\n        }\n    }\n\n    /**\n     * Process a batch of frames\n     *\n     * @private\n     * @param {number} initialFrameIndex - The index of frame to start.\n     */\n    private _processFrames(initialFrameIndex: number): void\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w) / this.resolution,\n                    Math.floor(sourceSize.h) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.h) / this.resolution,\n                        Math.floor(rect.w) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x) / this.resolution,\n                        Math.floor(rect.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y) / this.resolution,\n                        Math.floor(rect.w) / this.resolution,\n                        Math.floor(rect.h) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture(\n                    this.baseTexture,\n                    frame,\n                    orig,\n                    trim,\n                    data.rotated ? 2 : 0,\n                    data.anchor\n                );\n\n                // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n                Texture.addToCache(this.textures[i], i);\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /**\n     * Parse animations config\n     *\n     * @private\n     */\n    private _processAnimations(): void\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName] = [];\n            for (let i = 0; i < animations[animName].length; i++)\n            {\n                const frameName = animations[animName][i];\n\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /**\n     * The parse has completed.\n     *\n     * @private\n     */\n    private _parseComplete(): void\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /**\n     * Begin the next batch of textures.\n     *\n     * @private\n     */\n    private _nextBatch(): void\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     *\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    public destroy(destroyBase = false): void\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this._texture?.destroy();\n            this.baseTexture.destroy();\n        }\n        this._texture = null;\n        this.baseTexture = null;\n    }\n}\n\n/**\n * Reference to Spritesheet object created.\n * @member {PIXI.Spritesheet} spritesheet\n * @memberof PIXI.ILoaderResource\n * @instance\n */\n\n/**\n * Dictionary of textures from Spritesheet.\n * @member {object<string, PIXI.Texture>} textures\n * @memberof PIXI.ILoaderResource\n * @instance\n */\n","import { url } from '@pixi/utils';\nimport { Spritesheet } from './Spritesheet';\nimport { LoaderResource } from '@pixi/loaders';\nimport type { Loader, ILoaderResource } from '@pixi/loaders';\n\n/**\n * {@link PIXI.Loader} middleware for loading texture atlases that have been created with\n * TexturePacker or similar JSON-based spritesheet.\n *\n * This middleware automatically generates Texture resources.\n *\n * If you're using Webpack or other bundlers and plan on bundling the atlas' JSON,\n * use the {@link PIXI.Spritesheet} class to directly parse the JSON.\n *\n * The Loader's image Resource name is automatically appended with `\"_image\"`.\n * If a Resource with this name is already loaded, the Loader will skip parsing the\n * Spritesheet. The code below will generate an internal Loader Resource called `\"myatlas_image\"`.\n *\n * @example\n * loader.add('myatlas', 'path/to/myatlas.json');\n * loader.load(() => {\n *   loader.resources.myatlas; // atlas JSON resource\n *   loader.resources.myatlas_image; // atlas Image resource\n * });\n *\n * @class\n * @memberof PIXI\n * @implements PIXI.ILoaderPlugin\n */\nexport class SpritesheetLoader\n{\n    /**\n     * Called after a resource is loaded.\n     * @see PIXI.Loader.loaderMiddleware\n     * @param {PIXI.LoaderResource} resource\n     * @param {function} next\n     */\n    static use(resource: ILoaderResource, next: (...args: unknown[]) => void): void\n    {\n        // because this is middleware, it execute in loader context. `this` = loader\n        const loader = (this as any) as Loader;\n        const imageResourceName = `${resource.name}_image`;\n\n        // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n        if (!resource.data\n            || resource.type !== LoaderResource.TYPE.JSON\n            || !resource.data.frames\n            || loader.resources[imageResourceName]\n        )\n        {\n            next();\n\n            return;\n        }\n\n        // Check and add the multi atlas\n        // Heavily influenced and based on https://github.com/rocket-ua/pixi-tps-loader/blob/master/src/ResourceLoader.js\n        // eslint-disable-next-line camelcase\n        const multiPacks = resource.data?.meta?.related_multi_packs;\n\n        if (Array.isArray(multiPacks))\n        {\n            for (const item of multiPacks)\n            {\n                if (typeof item !== 'string')\n                {\n                    continue;\n                }\n\n                const itemName = item.replace('.json', '');\n                const itemUrl = url.resolve(resource.url.replace(loader.baseUrl, ''), item);\n\n                // Check if the file wasn't already added as multipacks are redundant\n                if (loader.resources[itemName]\n                    || Object.values(loader.resources).some((r) => url.format(url.parse(r.url)) === itemUrl))\n                {\n                    continue;\n                }\n\n                const options = {\n                    crossOrigin: resource.crossOrigin,\n                    loadType: LoaderResource.LOAD_TYPE.XHR,\n                    xhrType: LoaderResource.XHR_RESPONSE_TYPE.JSON,\n                    parentResource: resource,\n                };\n\n                loader.add(itemName, itemUrl, options);\n            }\n        }\n\n        const loadOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata.imageMetadata,\n            parentResource: resource,\n        };\n\n        const resourcePath = SpritesheetLoader.getResourcePath(resource, loader.baseUrl);\n\n        // load the image for this sheet\n        loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res: ILoaderResource)\n        {\n            if (res.error)\n            {\n                next(res.error);\n\n                return;\n            }\n\n            const spritesheet = new Spritesheet(\n                res.texture,\n                resource.data,\n                resource.url\n            );\n\n            spritesheet.parse(() =>\n            {\n                resource.spritesheet = spritesheet;\n                resource.textures = spritesheet.textures;\n                next();\n            });\n        });\n    }\n\n    /**\n     * Get the spritesheets root path\n     * @param {PIXI.LoaderResource} resource - Resource to check path\n     * @param {string} baseUrl - Base root url\n     */\n    static getResourcePath(resource: ILoaderResource, baseUrl: string): string\n    {\n        // Prepend url path unless the resource image is a data url\n        if (resource.isDataUrl)\n        {\n            return resource.data.meta.image;\n        }\n\n        return url.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}